import numpy as np
import copy

class eightPuzzleSolver():
    def __init__(self):
        self.currnet_node_state = None
        
        self.goal_state = [[1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 0]]
        
        # Turn goal state into a string for easier comparisons
        self.goal_state_string = self.getNodeID(np.array(self.goal_state))
        
        self.visited_states = []
        
        # Stores the string values of each visited puzzle so it can be easily checked against
        self.visited_node_configs = []
        
        # List of states that were generated by breadth first search that we need to continue to search through
        # Stored in the order they were generated to abide by breadth first search
        self.states_to_visit = []
        
        self.node_index = 0
        
        self.parent_node_index = 0
        
        # self.potential_moves = ["Up", "Down", "Left", "Right"]
        
    # Get the unique string made of the elements of the puzzle and return it as a string
    def getNodeID(self, puzzle):
        puzzle_as_string = ""
        for num in np.nditer(puzzle):
            puzzle_as_string += str(num)
            
        return puzzle_as_string
        
    # Gets the current location of the blank space as an (i, j) pair
    def getCurrentNodeState(self):
        print(self.currnet_node_state)
        empy_space_loc = np.where(self.currnet_node_state == 0)
        i = empy_space_loc[1][0]
        j = empy_space_loc[0][0]
        
        print("i, j = ({}, {})".format(i, j))
        return i, j
    
    # Determine the valid moves for a given puzzle state
    def determineValidMoves(self, i, j):
        valid_moves = []
        
        # Check if the tile can move up
        if j > 0:
            valid_moves.append("Up")
        # Check if the tile can move down
        if j < 2:
            valid_moves.append("Down")
            
        # Check if the tile can move left
        if i > 0:
            valid_moves.append("Left")
        # Check if the tile can move right
        if i < 2:
            valid_moves.append("Right")
            
        return valid_moves
            
    
    # Executes the valid moves
    def performValidMoves(self, valid_moves, i, j):
        goal_found = False
        for move in valid_moves:
            new_puzzle = self.moveBlankTile(move, i, j)
            
            puzzle_string = self.getNodeID(new_puzzle)
            
            # TODO: Check if the new puzzle is the goal puzzle so we can stop search and backtrace. Set goal flag so we return true
            if puzzle_string == self.goal_state_string:
                goal_found = True

            # Check if the state has already been checked
            if puzzle_string in self.visited_node_configs:
                continue
            else:
                # Add the unique node config string to the list of visited nodes so we don't visit it again
                self.visited_node_configs.append(puzzle_string)
                puzzle_node = {"parent_node": self.parent_node_index, "node_index": self.node_index, "puzzle_state": new_puzzle}
                
                self.states_to_visit.append(puzzle_node)
                
                self.node_index += 1

        print(self.states_to_visit)

            
    def moveBlankTile(self, move, i, j):
        # Make a copy of the current puzzle so we don't overwrite it
        temp_current_state = copy.copy(self.currnet_node_state)
        
        if move == "Up":
            temp_current_state[j-1, i], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j-1,i]
        elif move == "Down":
            temp_current_state[j+1, i], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j+1, i]
        elif move == "Left":
            temp_current_state[j, i-1], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j, i-1]
        elif move == "Right":
            temp_current_state[j, i+1], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j, i+1]
            
        return temp_current_state
    
    # Backtraces the state path once a path to the goal is found
    def generatePath(self):
        pass
    
    # Writes the finals nodes visited, node info, and path taken to files
    def writeFiles(self):
        pass
    
    # Main driver function for solving the puzzle for a given configuration
    def solvePuzzle(self, puzzle):
        # print(puzzle)
        self.currnet_node_state = np.array(puzzle)
        self.visited_states.append(self.currnet_node_state)
        self.node_index += 1
        i, j = self.getCurrentNodeState()
        
        valid_moves = self.determineValidMoves(i, j)
        self.performValidMoves(valid_moves, i, j)
        
        
    
if __name__ == "__main__":
    solver = eightPuzzleSolver()
    
    puzzle = [[1, 0, 6],
              [4, 3, 7],
              [2, 5, 8]]
    
    solver.solvePuzzle(puzzle)