import numpy as np
import copy

class eightPuzzleSolver():
    def __init__(self):
        self.currnet_node_state = None
        
        self.goal_state = [[1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 0]]
        
        self.visited_states = []
        
        # List of states that were generated by breadth first search that we need to continue to search through
        # Stored in the order they were generated to abide by breadth first search
        self.states_to_visit = []
        
        self.node_index_i = 0
        
        self.parent_node_index_i = 0
        
        # self.potential_moves = ["Up", "Down", "Left", "Right"]
        
    # Gets the current location of the blank space as an (i, j) pair
    def getCurrentNodeState(self):
        print(self.currnet_node_state)
        empy_space_loc = np.where(self.currnet_node_state == 0)
        i = empy_space_loc[1][0]
        j = empy_space_loc[0][0]
        
        print("i, j = ({}, {})".format(i, j))
        return i, j
    
    # Determine the valid moves for a given puzzle state
    def determineValidMoves(self, i, j):
        valid_moves = []
        
        # Check if the tile can move up
        if j > 0:
            valid_moves.append("Up")
        # Check if the tile can move down
        if j < 2:
            valid_moves.append("Down")
            
        # Check if the tile can move left
        if i > 0:
            valid_moves.append("Left")
        # Check if the tile can move right
        if i < 2:
            valid_moves.append("Right")
            
        return valid_moves
            
    
    # Executes the valid moves
    def performValidMoves(self, valid_moves, i, j):
        for move in valid_moves:
            new_puzzle = self.moveBlankTile(move, i, j)
            
    def moveBlankTile(self, move, i, j):
        # Make a copy of the current puzzle so we don't overwrite it
        temp_current_state = copy.copy(self.currnet_node_state)
        
        print(move)
        
        if move == "Up":
            temp_current_state[j-1, i], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j-1,i]
        elif move == "Down":
            temp_current_state[j+1, i], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j+1, i]
        elif move == "Left":
            temp_current_state[j, i-1], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j, i-1]
        elif move == "Right":
            temp_current_state[j, i+1], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j, i+1]
            
        print(temp_current_state)
    
    # Moves blank space left
    def ActionMoveLeft(self):
        pass
    
    # Moves blank space right
    def ActionMoveRight(self):
        pass
    
    # Moves blank space up
    def ActionMoveUp(self):
        pass
    
    # Moves blank space down
    def ActionMoveDown(self):
        pass
    
    # Backtraces the state path once a path to the goal is found
    def generatePath(self):
        pass
    
    # Writes the finals nodes visited, node info, and path taken to files
    def writeFiles(self):
        pass
    
    # Main driver function for solving the puzzle for a given configuration
    def solvePuzzle(self, puzzle):
        # print(puzzle)
        self.currnet_node_state = np.array(puzzle)
        i, j = self.getCurrentNodeState()
        
        valid_moves = self.determineValidMoves(i, j)
        self.performValidMoves(valid_moves, i, j)
        
        
    
if __name__ == "__main__":
    solver = eightPuzzleSolver()
    
    puzzle = [[1, 0, 6],
              [4, 3, 7],
              [2, 5, 8]]
    
    solver.solvePuzzle(puzzle)