import numpy as np
import copy

class eightPuzzleSolver():
    def __init__(self):
        self.current_node_state = {}
        
        self.goal_state = [[1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 0]]
        
        # Turn goal state into a string for easier comparisons
        self.goal_state_string = self.getNodeID(np.array(self.goal_state))
        
        self.visited_states = []
        
        # Stores the string values of each visited puzzle so it can be easily checked against
        self.visited_node_configs = []
        
        # List of states that were generated by breadth first search that we need to continue to search through
        # Stored in the order they were generated to abide by breadth first search
        self.states_to_visit = []
        
        self.node_index = 0
        
        self.parent_node_index = 0
        
    # Get the unique string made of the elements of the puzzle and return it as a string
    def getNodeID(self, puzzle):
        puzzle_as_string = ""
        # Iterate through the values in the numpy array in order
        for num in np.nditer(puzzle):
            puzzle_as_string += str(num)
            
        return puzzle_as_string
        
    # Gets the current location of the blank space as an (i, j) pair
    def getCurrentNodeState(self):
        # print(self.current_node_state)
        
        # Extract the puzzle from the current node state dict
        puzzle = self.current_node_state["puzzle_state"]
        
        # Get the location of the blank tile (where the value is 0)
        empy_space_loc = np.where(puzzle == 0)
        i = empy_space_loc[1][0]
        j = empy_space_loc[0][0]
        
        # print("i, j = ({}, {})".format(i, j))
        return i, j
    
    # Determine the valid moves for a given puzzle state
    def determineValidMoves(self, i, j):
        valid_moves = []
        
        # Check if the tile can move up
        if j > 0:
            valid_moves.append("Up")
        # Check if the tile can move down
        if j < 2:
            valid_moves.append("Down")
            
        # Check if the tile can move left
        if i > 0:
            valid_moves.append("Left")
        # Check if the tile can move right
        if i < 2:
            valid_moves.append("Right")
            
        return valid_moves
            
    
    # Executes the valid moves
    def performValidMoves(self, valid_moves, i, j):
        goal_found = False
        for move in valid_moves:
            new_puzzle = self.moveBlankTile(move, i, j)
            
            puzzle_string = self.getNodeID(new_puzzle)
            
            # Check if the new puzzle is the goal puzzle so we can stop search and backtrace. Set goal flag so we return true
            if puzzle_string == self.goal_state_string:
                goal_found = True
                print("PUZZLE SOLVED!")
                print(new_puzzle)

            # Check if the state has already been checked
            # TODO: This might be causing the issue where we don't always find a solution
            if puzzle_string in self.visited_node_configs:
                continue
            else:
                # Add the unique node config string to the list of visited nodes so we don't visit it again
                self.visited_node_configs.append(puzzle_string)
                puzzle_node = {"parent_node": self.parent_node_index, "node_index": self.node_index, "puzzle_state": new_puzzle}
                
                # Add the new puzzle node to the end of the queue
                self.states_to_visit.append(puzzle_node)
                
                self.node_index += 1
                
            if goal_found:
                break

        # print(self.states_to_visit)
        # print(self.visited_node_configs)
        
        return goal_found

    # Given the move type and the location of the tile, a new puzzle state is created with the blank tile being swapped with another
    def moveBlankTile(self, move, i, j):
        # Make a copy of the current puzzle so we don't overwrite it
        temp_current_state = copy.copy(self.current_node_state["puzzle_state"])
        
        # Kind of want to make this a switch statement but don't want to make it dependent on python>3.10
        if move == "Up":
            temp_current_state[j-1, i], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j-1,i]
        elif move == "Down":
            temp_current_state[j+1, i], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j+1, i]
        elif move == "Left":
            temp_current_state[j, i-1], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j, i-1]
        elif move == "Right":
            temp_current_state[j, i+1], temp_current_state[j, i] = temp_current_state[j, i], temp_current_state[j, i+1]
            
        return temp_current_state
    
    # Backtraces the state path once a path to the goal is found
    def generatePath(self, node):
        node_path = []
        # Append the final node to the path and start from there
        node_path.append(node)

        parent_id = node["parent_node"]
        
        # Loop through parent nodes until we get to the starting node of 0
        while not (parent_id == 0):
            # Grab the parent node by its index ID from the list of visited puzzle states
            parent_node = self.visited_states[parent_id]
            
            # Append the parent node to the path
            node_path.append(parent_node)
            
            # Update the parent ID to go to next with the parent node of this new node
            parent_id = parent_node["parent_node"]
            
        # Finally append the starting node on since it will be the common start for all paths
        node_path.append(self.visited_states[0])
        
        # print(node_path)    
        # Reverse the path and return it
        node_path.reverse()
        # print(node_path)
        
        return node_path
        
    
    # Writes the finals nodes visited, node info, and path taken to files
    def writeFiles(self, node_id_path):
        # Loop through the visited states first and write them to the file
        # Save the puzzles in the proper format so they can be added to the file for all explored states
        saved_visited_states = []
        node_id_list = []
        parent_id_list = []
        
        nodes_info_file = open("NodesInfo.txt", "w")
        nodes_info_file.write("Node_index \t Parent_Node_index \t Node \n")
        
        nodes_file = open("Nodes.txt", "w")
        
        # Loop through the visited states to build the nodes file and part of the nodes info file
        for puzzle_state in self.visited_states:
            # Grab the puzzle array from the dictionary
            puzzle = puzzle_state["puzzle_state"]
    
            fixed_puzzle = ""
            
            # Loop through the length (3 rows) of the puzzle and grab the correct elements from each row to append to make it column order
            for i in range(len(puzzle)):
                fixed_puzzle += str(puzzle[0][i]) + " " + str(puzzle[1][i]) + " " + str(puzzle[2][i]) + " "
                
            fixed_puzzle += "\n"
                
            nodes_file.write(fixed_puzzle)
            
            # Get the node and parent IDs so they can be written to the nodes info file
            node_id = puzzle_state["node_index"]
            parent_node = puzzle_state["parent_node"]
            
            # Build the nodes info string
            node_info = str(node_id) + "\t" + str(parent_node) + "\t" + fixed_puzzle
            
            nodes_info_file.write(node_info)
            
        # TODO: Write the rest of the nodes info states from states to visit list
        for puzzle_state in self.states_to_visit:
            # Grab the puzzle array from the dictionary
            puzzle = puzzle_state["puzzle_state"]
    
            fixed_puzzle = ""
            
            # Loop through the length (3 rows) of the puzzle and grab the correct elements from each row to append to make it column order
            for i in range(len(puzzle)):
                fixed_puzzle += str(puzzle[0][i]) + " " + str(puzzle[1][i]) + " " + str(puzzle[2][i]) + " "
                
            fixed_puzzle += "\n"
            
            # I'm pretty sure the standard nodes file only wants fully explored nodes and not just the visited ones
            # nodes_file.write(fixed_puzzle)
            
            # Get the node and parent IDs so they can be written to the nodes info file
            node_id = puzzle_state["node_index"]
            parent_node = puzzle_state["parent_node"]
            
            # Build the nodes info string
            node_info = str(node_id) + "\t" + str(parent_node) + "\t" + fixed_puzzle
            
            nodes_info_file.write(node_info)
            
        node_path_file = open("nodePath.txt", "w")
        # Write the path to a file
        for puzzle_state in node_id_path:
            # Grab the puzzle array from the dictionary
            puzzle = puzzle_state["puzzle_state"]
    
            fixed_puzzle = ""
            
            # Loop through the length (3 rows) of the puzzle and grab the correct elements from each row to append to make it column order
            for i in range(len(puzzle)):
                fixed_puzzle += str(puzzle[0][i]) + " " + str(puzzle[1][i]) + " " + str(puzzle[2][i]) + " "
                
            fixed_puzzle += "\n"
                
            node_path_file.write(fixed_puzzle)
            
    
    # Main driver function for solving the puzzle for a given configuration
    def solvePuzzle(self, puzzle):
        # print(puzzle)
        self.current_node_state = {"parent_node": self.parent_node_index, "node_index": self.node_index, "puzzle_state": np.array(puzzle)}
        
        # Append the starting state to both the states to visit and the config tracking list
        self.states_to_visit.append(self.current_node_state)
        self.visited_node_configs.append(self.getNodeID(self.current_node_state["puzzle_state"]))
        
        self.node_index += 1
        
        while len(self.states_to_visit) > 0:
        
            # Get the next node to expand from front of the queue
            self.current_node_state = self.states_to_visit.pop(0)
            
            self.parent_node_index = self.current_node_state["node_index"]
        
            # Find the location of the blank tile as an i, j array index
            i, j = self.getCurrentNodeState()
            
            # Determine all valid moves, a list of directions, given the location of the blank tile
            valid_moves = self.determineValidMoves(i, j)
            
            # Perform all valid moves and see if any of them put the puzzle into the desired goal state
            goal_found = self.performValidMoves(valid_moves, i, j)
            
            # Add the current node to the list of fully checked nodes
            self.visited_states.append(self.current_node_state)
            
            # If we've found the goal break out of the loop
            if goal_found:
                break
            
        final_node = self.states_to_visit[-1]
        
        node_id_path = self.generatePath(final_node)
        
        self.writeFiles(node_id_path)
            
        # TODO: Add calls to generate the path via backtracing from the goal node using parent node IDs then write all that to files
        
        
        
        
    
if __name__ == "__main__":
    solver = eightPuzzleSolver()
    
    # puzzle = [[1, 0, 6],
    #           [4, 3, 7],
    #           [2, 5, 8]]
    
    puzzle = [[1, 2, 3],
              [4, 0, 6],
              [7, 5, 8]]
    
    solver.solvePuzzle(puzzle)